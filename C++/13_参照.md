13 参照
=======

## 1. 参照の役目

* C++には、オブジェクトを操作する方法として以下のものがある

  * 変数

  * ポインタ

  * 参照(リファレンス)

* 参照は、オブジェクトの別名に過ぎない

  * ただし、関数の仮引数で使用すると、見かけは「値渡し」なのに、実質はポインタ渡しと同じ効果となる



## 2. 参照の宣言

* 宣言と同時にオブジェクトのアドレスを初期設定する必要がある

* 以下の場合、初期設定は不要

  1. 関数仮引数及び関数戻り値型の場合：関数呼び出し時、関数終了時に初期化

  2. クラスのデータメンバの場合：コンストラクタで初期化

  3. `extern`指定子を含む場合：`extern int& r;`のように記述

```cpp
int dt;
int& rf = dt;

dt = 100;
rf = 200;
```



## 3. 参照とポインタの比較

1. 参照のアドレス設定は初期化のときである。ポインタはいつでもアドレス設定ができる

2. 参照と設定したオブジェクトアドレスとの結合は、プログラムが終了するまで解かれることはない。ポインタはいつでも設定変更できる

3. ポインタは自身を変更できるが、参照には自身を変更する演算子はない

> 参照はアドレス処理が自動的に行われる

```cpp
int dt;
int& rf = dt;
int* pt = &dt;

rf = 100;
*pt = 200;

// rf = &dt;
pt = &dt;

pt = &rf;

++pt;
--rf;
```



## 4. 参照と定数処理

* 参照はオブジェクトのアドレスを自動的に設定するものだが、定数のアドレスも設定可能

  * ただし、その場合は属性を`const`にする

```cpp
// int& n = 1234;
const int& n = 1234;
cout << n << endl;
```



## 5. 参照で配列を処理する

* 参照で配列先頭を管理することはできる

```cpp
int a[5] = { 10, 20, 30, 40, 50 };
int (&r)[5] = a;
cout << r[0] << " " << r[4] << endl;
```



## 6. 参照を仮引数に使う

```cpp
swap_p(&a, &b);
swap_r(a, b);
```



| 版  | 年月日     |
| --- | ---------- |
| 1st | 2020/08/16 |
