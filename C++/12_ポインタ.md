12 ポインタ
==========

## 1. ポインタの基本用法

### ポインタの宣言

* ポインタ：アドレスを保持できる機能

  * オブジェクトは、メモリ上に配置されたアドレスを持つ

  * 関数は、実行開始のアドレスを持っている

```cpp
char *cp; // cpはchar型オブジェクトへのポインタ
int *ip;  // ipはint型オブジェクトへのポインタ
```

* ポインタ宣言は、以下の三種類

```cpp
int *pt;
int* pt;
int * pt;
```

* ポインタは宣言時に型を指定するが、この型より現在保持しているアドレスから何バイトを処理対象にするかを決める

```cpp
char *cp;
int *ip;
double *dp;
```



### アドレス取得と間接参照

* `&`：対象オペランドのアドレスを返す

* `*`：対象オペランドを間接参照する

```cpp
char a, b;
char *p;
p = &a;
*p = 50;
b = *p;
```



### ポインタの初期化と設定と空ポインタ定数

* アドレスは、初期化や代入処理で設定できる

* 空ポインタ定数である`0`をポインタに直接設定できる

  * 意味のあるアドレスがまだ設定されていない

  * ポインタが特別な意味にある(エラー発生など)

```cpp
// 例1：変数のアドレスを&演算子で代入する
int d, *p;
p = &d;

// 例2：配列の先頭アドレスを代入する
// 配列名sを単独で指定すると、配列全体の先頭アドレスに評価される
char s[80], *p;
p = s;

// 例3：配列の1要素のアドレスを&演算子で代入する
char s[80], *p;
p = &s[3];
p = &s[0];

// 例4：char型ポインタに文字列リテラルの先頭アドレスを設定する
const char *p;
p = "abcd";

// 例5：プログラム実行後、動的にメモリを確保し、その先頭アドレスを設定する
char *p;
p = new char[500];

// 例6：空ポインタ定数を設定
char *p;
p = 0;
p = NULL;

// 例7：初期化で設定
int d, *p1 = &d;
char s[80];
char *p2 = s;
const char *p3 = "abcde";
char *p4 = new char[500];
char *p5 = 0;
```



### ポインタの演算

**1. ポインタと整数の加算・減算及びポインタの増分・減分処理**

* ポインタを1加算すると、一つ次の要素を指す

```cpp
int n, ary[5] = {10, 11, 12, 13, 14}, *p, *p1, *p2;

p = ary;
n = *p;            // n:10
n = *(p + 2);      // n:12
p = p + 2; n = *p; // n:12
++p; n = *p;       // n:13
--p; n = *p;       // n:12
p = p - 2; n = *p; // n:10n
```



**2. ポインタ同士の減算処理**

* 両方のポインタが同じ配列の要素を指しているときに実用的

```cpp
p1 = ary;     // ary[0]のアドレス
p2 = ary + 2; // ary[2]のアドレス
n = p2 - p1;  // 減算実行。nは2
```



**3. ポインタの等価、比較判定**

```cpp
p1 = ary;
p2 = ary + 2;
if (p1 == 0)    n = 1; else n = 2; // nは2
if (p1 == NULL) n = 1; else n = 2; // nは2
if (p1 == p2)   n = 1; else n = 2; // nは2
if (p1 < p2)    n = 1; else n = 2; // nは1
```



### void型ポインタの処理

* void型ポインタには、どのような型のポインタも代入できる

* void型ポインタを関数仮引数に使うことも可能

```cpp
void *p;
int foo(int n, void *p);
```

* 非void型である場合は、void型ポインタに暗黙のうちに変換できる

* void型ポインタ型から個別ポインタの変換は、キャスト操作でポインタ種別を指定する必要がある

```cpp
void* vp;
char* cp;
int*  ip;

vp = cp;
vp = ip;
// cp = vp;
// ip = vp;
cp = static_cast<char*>(vp);
ip = static_cast<int*>(vp);
```



## 2. ポインタと配列操作

### ポインタと配列表現

* ポインタを使って、配列風の表現が可能

* 配列名を使って、ポインタ的表現が可能

  * 配列名：確保配列の先頭アドレスを示すポインタとして評価される

  * ポインタを使った記述と、配列名を使った記述は同じスタイルにできる

```cpp
char c1, c2, s[] = "ABCDE", *p = s;
c1 = *p;     c2 = *s;     // c1, c2:'A'
c1 = p[2];   c2 = s[2];   // c1, c2:'C'
c1 = *(p+3); c2 = *(s+3); // c1, c2:'D'
```



### 名前と添字は位置互換

* ポインタや配列名を使った添字式は以下の通り

  * 名前(ポインタ)と添字は位置互換

```cpp
*((E1)+(E2)) // 一方がポインタ、他方が整数
```

```cpp
char ch, s[] = "ABCDE", *p = s;
ch = s[2];
ch = 2[s];
ch = p[2];
ch = 2[p];
ch = "abcde"[2];
ch = 2["abcde"];
```



## 3. ポインタ配列

* ポインタ配列は、以下の通りに宣言する

```cpp
char *pp[10];
```

* 配列では、それぞれの配列要素(長さ10)に、データの実体が入る

* ポインタでは、3つの文字列をメモリ上のどこかに確保し、その先頭番地をそれぞれのポインタに入れる


```cpp
// char型の多次元文字列
char namev[3][10] = { "January", "February", "March" };
cout << namev[2] << endl;

// ポインタ配列
const char *namep[3] = { "January", "February", "March" };
cout << namep[2] << endl;
```



## 4. ポインタのポインタ

* ポインタのポインタを宣言できる

> 例：char型の値を指すポインタを指すポインタ

```cpp
char **pp;
```

| 宣言        | 説明                                                                                   |
| ----------- | -------------------------------------------------------------------------------------- |
| `char a;`   | `a`はchar型の変数                                                                      |
| `char *b;`  | `*b`という記述がchar型, `b`はchar型へのポインタ                                        |
| `char **c;` | `**c`という記述がchar型, `*c`はchar型へのポインタ, `c`はchar型へのポインタへのポインタ |

* ポインタのポインタは、以下の例の時に便利

  * ポインタは通常の配列を管理する

  * ポインタのポインタは、ポインタの配列を管理する

```cpp
char *p, ss[] = "ABC";
const char **pp, *month[3] = { "January", "February", "March" };

for (p=ss; *p*; p++)
  cout << *p;
cout << endl;
for (pp=month; pp<month+3, pp++)
  cout << *pp << endl;
```



## 5. 関数を指すポインタ

* 関数を指すポインタを宣言することが可能

* 関数は、実行コードの入り口というアドレスを持っており、このアドレスをポインタに格納する

```cpp
int fnc(int n);     // int型を返す関数fnc
int *fnc(int n);    // int型へのポインタを返すfnc
int (*fnc)(int n);  // int型を返す関数であるfnc
```

```cpp
#include <iostream>
using namespace std;

int add(int a, int b);     // 普通の関数プロトタイプ
int sub(int a, int b);     // 普通の関数プロトタイプ
int (*calc)(int a, int b); // 関数へのポインタの宣言

int add(int a, int b)
{
  return a + b;
}

int sub(int a, int b)
{
  return a - b;
}

int main()
{
  calc = add;
  cout << calc(30, 20) << endl;
  calc = sub;
  cout << calc(30, 20) << endl;
  return 0;
}
```



| 版  | 年月日     |
| --- | ---------- |
| 1st | 2020/08/16 |
