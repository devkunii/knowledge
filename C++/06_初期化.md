06 初期化
========

## 1. 初期化のタイミング

* 初期化：変数を宣言したときに設定する初期値

* 自動記憶域期間を持つオブジェクト：実行がその宣言に到達するたびに初期化される

* 静的記憶域期間を持つオブジェクト：グローバルオブジェクトの場合、`main()`関数を実行する前に一度だけ初期化される

* 静的なローカルオブジェクト：実行がその宣言に初めて到達したときに一度だけ初期化される



## 2. 暗黙の初期化

* 初期化を行わなかった場合、自動変数は不定値になる

* 静的記憶域区間をもつオブジェクト(グローバル変数など)は、暗黙のうちにゼロ初期化(0系の初期化)が行われる

```cpp
// 0になる
int n;

// 0になる
int* p;

// ""になる
char s[80];

void foo()
{
  int n2;        // 不定値となる
  static int n3; // 0になる
  int* p2;       // 不定値となる
  char s2[80];   // 不定値となる
}
```



## 3. 初期化の方法1

### 初期化の形式

* 変数宣言をするときに初期値を指定する

* クラスの場合は、コンストラクタを使った初期化を行う

```cpp
int a = 10;
int b(20);
int c[3] = { 10, 20, 30 };
```



### 単純変数の初期化

```cpp
int a = 10;
int b = a;
int c = a * 2;
int d = func(20);
int e(30);
const int f = 40;
static int g = 50;
static int h = a;
int k = { 10 };
```



### 集成体の初期化

* スカラ型：算術型、列挙型、ポインタ型などの総称

* 集成体：配列型や以下の要素を持たないクラス

  * 利用者宣言のコンストラクタ

  * 非公開または限定公開の非静的データメンバ

  * 基底クラス

  * 仮想関数



### 配列の初期化

* 配列は集成体なので、`{}`で初期化可能

* 初期値の数が、

  * 配列サイズよりも大きいときはエラーと成る

  * 少ないときは、残りの要素がゼロ初期化される

* 初期化子を略して`{}`だけの指定も可能、全要素がゼロ初期化

* 初期化を行う場合、1次元配列の長さは省略できる

  * 多次元配列の先頭次元の長さは省略できる

* 初期化子のリストは、最後の初期値の後ろにコンマをおいても良い

```cpp
int a[4] = { 10, 20, 30, 40 };
int b[4] = { 10, 20 };
int c[] = { 10, 20, 30, 40 };
// int d[4] = { 10, 20, 30, 40, 50 };
int e[100] = { };
int f[2][3] = { 10, 20, 30, 40, 50, 60 };
int g[2][3] = { { 10, 20, 30 }, { 40, 50, 60 } };
int h[2][3] = { { 10 }, { 40, 50 }};
int[][3] = { { 10, 20, 30 }, { 40, 50, 60 } };
int j[2][3] = {
  { 10, 20, 30 },
  { 40, 50, 60 }
};
int k[2][3] = {
  { 10, 20, 30 },
  { 40, 50, 60 },
};
```



### 文字配列の初期化

* 通常配列と同じ`{}`による初期化、もしくは文字列リテラルで初期化可能

* 配列長より初期化要素のサイズが、

  * 大きい：エラー

  * 小さい：残りの部分がゼロ初期化

* 文字列リテラル`"ABCD"`の必要格納サイズは、5(末尾の`\0`も入る)

```cpp
char a[5] = "ABCD";
char b[5] = { 'A', 'B', 'C', 'D', '\0' };
char c[5] = { 65, 66, 67, 68, 69 };
// char e[5] = "ABCDEF";
char f[10] = "abcd";
char g[10] = { "abcd" };
char h[10] = { };
char days[3][10] = { "Sunday", "Monday", "Tuesday" };
wchar_t w[10] = L"wide文字列です。"
```



### String型の初期化

```cpp
string ss = "これは文字列です";
string str[2] = { "文字列a", "文字列b" };
```



## 4. 初期化の方法2

### ポインタと参照の初期化

* `&`：アドレスを取得する演算子

* 配列名は、それ自身がアドレスに評価されるため、`&`を使わなくて良い

```cpp
int d;
int* p = &d;

char s[80];
char* p = s;
```



### クラスの初期化

* コンストラクタで行われる

```cpp
class Mycls{
public:
  int x, y;
  Mycls() { x = 0; y = 0; }
  Mycls(int n1) { x = n1; y = 0 }
  Mycls(int n1, int n2) { x = n1, y = n2; }
};

Mycls d1;
Mycls d2 = Mycls();
Mycls d3(10);
Mycls d4 = Mycls(10);
Mycls d5 = 10;
Mycls d6(30, 40);
Mycls d7 = Mycls(30, 40);
Mycls d8 = d7;
Mycls d9[2] = { Mycls(50, 55), Mycls(60, 65) };
```



### 構造体と共用体の初期化

* `{}`で初期化可能

  * 構造体：メンバの順に対して初期値を指定

  * 共用体：先頭メンバに対して初期値を指定

* 同型の宣言済みの集成体オブジェクトで初期化しても良い

```cpp
// 構造体
struct Sdata { int x; int y; };
Sdata d = { 640, 400 };
Sdata e = d;

// 共用体
union Udata { int id; char ch; };
Udata d = { 1000 };
```



| 版  | 年月日     |
| --- | ---------- |
| 1st | 2020/08/12 |
