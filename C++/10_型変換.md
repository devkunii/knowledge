10 型変換
========

* 型変換：異なる型の間でのデータのやり取り、異なる型の混合演算

* 型変換には、以下の2種類がある

  * 自動型変換

  * 明示的型変換



## 1. 自動型変換

### 代入時型変換

* 自動型変換は、代入と演算の2つのケースで発生する

  * コンパイラが自動的に無難な型変換を行う

* 代入処理を行うと、右辺の値は左辺のデータ型に変換される

* 警告レベルを強くしてコンパイルすると、表現能力の低い型への変換が行われた場合、警告メッセージが表示される

```cpp
char   char_dt;
int    int_dt;
float  float_dt;
double double_dt;

int_dt = char_dt;     // 汎整数昇格
double_dt = float_dt; // 浮動小数点数昇格
char_dt = int_dt;     // 汎整数変換
float_dt = double_dt; // 浮動小数点数変換
int_dt = double_dt;   // 汎整数と浮動小数点数の変換
float_dt = int_dt;    // 浮動小数点数と汎整数の変換
```



### 関数の引数型変換

* 関数を呼び出すときにも、型変換は発生する

  * 関数の仮引数と、呼び出し元の実引数との間で、初期化が行われる

```cpp
func(123);

// int型から、double型に変換される
void func(double d)
{

}
```



### 整数昇格と浮動小数点昇格

* 整数昇格(整数格上げ)：算術演算で右辺値として評価される、小さな整数型

  * これで大きすぎる整数型を、int以上の型に揃える

* 浮動小数点数も、必要であれば昇格される



**整数昇格ルール**

1. `char`, `signed char`, `unsigned char`, `short int`, `unsigned short int`は、`int`, `unsigned int`の中で表現可能な最初の型に変換される

2. `bool`は、`int`型に変換される(`false`：`0`、`true`：`1`)

3. `wchar_t`と列挙型は`int`, `unsigned int`, `long`, `unsigned long`の中で表現可能な最初の型に変換される

4. ビットフィールドは、`int`, `unsigned int`の中で表現可能な最初の型に変換される



**浮動小数点昇格ルール**

`float`型の右辺値は、`double`型の右辺値に昇格できる



### 算術変換

* 算術変換：二項演算を行う場合、双方の項は演算に先立って、精度の高い方の方に統一される



### 真理値変換

* 算術型、列挙型、ポインタ型は、`bool`型の右辺値に真理値変換できる

  * `false`：ゼロ及び空ポインタ(`0`)

  * `true`：その他の値



### クラスの暗黙の型変換

* 値をクラス型に変換：クラスに`explicit`無しの適切なコンストラクタが用意されている場合

* クラス型をそのクラス型でない値に変換：適切な変換関数(変換演算子)が用意されている場合

```cpp
int n;
Mycls c = 10; // 整数からMycls型への変換
c = 20;
n = c;        // Mycls型から整数への変換
```



## 2. 明示的型変換

### C形式キャスト

```cpp
// (型) 式
a = (int)b;

a = static_cast<int>(b);
```



### 関数形式キャスト

* 変更しようとする型の名前が単純型名の場合

* このキャストを多用する場合、`typedef`で新しい型を宣言することで記法を変形できる

```cpp
// 単純型指定子(式)
a = int(b);

// p = int*(ss);

typedef int* intptr;
p = intptr(ss);
```



| 版  | 年月日     |
| --- | ---------- |
| 1st | 2020/08/14 |
